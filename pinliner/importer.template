import sys
import types

PINLINER_MODULE_NAME = 'pinliner_loader'

inliner_importer_code = '''
import os
import sys
import types


class InlinerImporter(object):
    def __init__(self, data):
        self.data = data

    def _get_module(self, fullname):
        fullname = fullname.split('.')
        module = self.data
        for name in fullname:
            module = module.get(name)
            if not module:
                return None
        return module

    def find_module(self, fullname, path):
        module = self._get_module(fullname)
        if module:
            return self

    def load_module(self, fullname):
        # If the module it's already in there we'll reload but won't remove the
        # entry if we fail
        exists = fullname in sys.modules
        # Get the module from the data
        code = self._get_module(fullname)

        module = types.ModuleType(fullname)
        module.__loader__ = self
        path = fullname.replace('.', os.path.sep)

        if isinstance(code, dict):
            # For packages we have to read the code in __init__
            code = code.get('__init__')
            module.__package__ = fullname
            module.__file__ = os.path.join(path, '__init__.py')
            module.__path__ = [path]
        else:
            module.__package__ = fullname.rsplit('.', 1)[0]
            module.__file__ = path + '.py'

        sys.modules[fullname] = module

        try:
            compiled_code = compile(code, module.__file__, 'exec')
            exec compiled_code in module.__dict__
        except:
            if not exists:
                del sys.modules[fullname]
            raise

        return module
'''


inliner_packages = {
${CONTENTS}
}


def prepare_package():
    # If the loader code is not already loaded we create a specific module for
    # it.  We need to do it this way so that the functions in there are not
    # compiled with a reference to this module's global dictionary in
    # __globals__.
    module = sys.modules.get(PINLINER_MODULE_NAME)
    if not module:
        module = types.ModuleType(PINLINER_MODULE_NAME)
        module.__package__ = ''
        module.__file__ = PINLINER_MODULE_NAME + '.py'
        exec inliner_importer_code in module.__dict__
        sys.modules[PINLINER_MODULE_NAME] = module

    # Add our own finder and loader for this specific package if it's not
    # already there.
    # This must be done before we initialize the package, as it may import
    # packages and modules contained in the package itself.
    if not any(isinstance(mp, module.InlinerImporter) and
               mp.data == inliner_packages for mp in sys.meta_path):
        sys.meta_path.append(module.InlinerImporter(inliner_packages))

    # Execute package's init code into a new dictionary
    module_dict = {}
    filename = __name__ + '/__init__.py'
    compiled_code = compile(inliner_packages[__name__]['__init__'], filename,
                            'exec')
    exec compiled_code in module_dict

    # Fix package variables in that dictionary
    module_dict.update(__path__=[__name__],
                       __file__=filename,
                       __package__=__name__,
                       __name__=__name__)

    # Now change this modules global namespace so it matches package's original
    # namespace
    globals().clear()
    globals().update(module_dict)


# Prepare loader's module and populate this namespace only with package's
# __init__
prepare_package()
