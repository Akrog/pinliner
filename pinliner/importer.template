import os
import sys
import types

PINLINER_MODULE_NAME = 'pinliner_loader'

FORCE_EXC_HOOK = %{FORCE_EXC_HOOK}

inliner_importer_code = '''
import os
import sys
import types


class InlinerImporter(object):
    def __init__(self, data, datafile, set_excepthook=True):
        self.data = data
        self.datafile = datafile
        if set_excepthook:
            sys.excepthook = self.excepthook

    @staticmethod
    def excepthook(type, value, traceback):
        import traceback as tb
        tb.print_exception(type, value, traceback)

    def _get_module(self, fullname):
        fullname = fullname.split('.')
        module = self.data
        for name in fullname:
            module = module.get(name)
            if not module:
                return None
        return module

    def find_module(self, fullname, path):
        module = fullname in self.data
        if module:
            return self

    def get_source(self, fullname, return_is_package=False):
        is_package, start, end = self.data[fullname]
        with open(self.datafile) as datafile:
            datafile.seek(start)
            code = datafile.read(end - start)
        if return_is_package:
            return is_package, code
        return code

    def load_module(self, fullname):
        # If the module it's already in there we'll reload but won't remove the
        # entry if we fail
        exists = fullname in sys.modules

        module = types.ModuleType(fullname)
        module.__loader__ = self

        is_package, code = self.get_source(fullname, True)

        path = fullname.replace('.', os.path.sep)
        if is_package:
            module.__package__ = fullname
            module.__file__ = os.path.join(path, '__init__.py')
            module.__path__ = [path]
        else:
            module.__package__ = fullname.rsplit('.', 1)[0]
            module.__file__ = path + '.py'

        sys.modules[fullname] = module

        try:
            compiled_code = compile(code, module.__file__, 'exec')
            exec compiled_code in module.__dict__
        except:
            if not exists:
                del sys.modules[fullname]
            raise

        return module
'''

${CONTENTS}

def prepare_package():
    # If the loader code is not already loaded we create a specific module for
    # it.  We need to do it this way so that the functions in there are not
    # compiled with a reference to this module's global dictionary in
    # __globals__.
    module = sys.modules.get(PINLINER_MODULE_NAME)
    if not module:
        module = types.ModuleType(PINLINER_MODULE_NAME)
        module.__package__ = ''
        module.__file__ = PINLINER_MODULE_NAME + '.py'
        exec inliner_importer_code in module.__dict__
        sys.modules[PINLINER_MODULE_NAME] = module

    # Add our own finder and loader for this specific package if it's not
    # already there.
    # This must be done before we initialize the package, as it may import
    # packages and modules contained in the package itself.
    for finder in sys.meta_path:
        if (isinstance(finder, module.InlinerImporter) and
                finder.data == inliner_packages):
            importer = finder
    else:
        # If we haven't forced the setting of the uncaught exception handler
        # we replace it only if it hasn't been replace yet, this is because
        # CPython default handler does not use traceback or even linecache, so
        # it never calls get_source method to get the code, but for example
        # iPython does, so we don't need to replace the handler.
        if FORCE_EXC_HOOK is None:
            set_excepthook = sys.__excepthook__ == sys.excepthook
        else:
            set_excepthook = FORCE_EXC_HOOK

        importer = module.InlinerImporter(inliner_packages, __file__,
                                          set_excepthook)
        sys.meta_path.append(importer)

    # Execute package's init code into a new dictionary
    module_dict = {}

    __, start, end = inliner_packages[__name__]
    # We canno use __file__ directly because on the second run __file__ will
    # be the compiled file (.pyc) and that's not the file we want to read.
    filename = os.path.splitext(__file__)[0] + '.py'
    with open(filename) as datafile:
        datafile.seek(start)
        code = datafile.read(end - start)

    filename = __name__ + '/__init__.py'
    compiled_code = compile(code, filename, 'exec')
    exec compiled_code in module_dict

    # Fix package variables in that dictionary
    module_dict.update(__path__=[__name__],
                       __file__=filename,
                       __package__=__name__,
                       __name__=__name__,
                       __loader__=importer)

    # Now change this modules global namespace so it matches package's original
    # namespace
    globals().clear()
    globals().update(module_dict)


# Prepare loader's module and populate this namespace only with package's
# __init__
prepare_package()
